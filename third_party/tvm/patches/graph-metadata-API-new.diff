diff --git a/include/tvm/runtime/ndarray.h b/include/tvm/runtime/ndarray.h
index 99329517984..2eaaa4b2eb4 100644
--- a/include/tvm/runtime/ndarray.h
+++ b/include/tvm/runtime/ndarray.h
@@ -26,6 +26,7 @@
 
 #include <atomic>
 #include <vector>
+#include <string>
 #include <utility>
 #include "c_runtime_api.h"
 #include "serializer.h"
@@ -194,6 +195,7 @@ class NDArray {
 
   // internal namespace
   struct Internal;
+  std::string name_hint;
  protected:
   /*! \brief Internal Data content */
   Container* data_{nullptr};
diff --git a/src/runtime/graph/graph_runtime.cc b/src/runtime/graph/graph_runtime.cc
index 06e5fef43de..376b65504fa 100644
--- a/src/runtime/graph/graph_runtime.cc
+++ b/src/runtime/graph/graph_runtime.cc
@@ -108,6 +108,21 @@ void GraphRuntime::SetInput(int index, DLTensor* data_in) {
   uint32_t eid = this->entry_id(input_nodes_[index], 0);
   data_entry_[eid].CopyFrom(data_in);
 }
+/*!
+ * \brief Get the graph input index given the name of input.
+ * \param name The name of the input.
+ * \return The index of graph input.
+ */
+int GraphRuntime::GetGraphInputIndex(const std::string& name) {
+  for (size_t i = 0; i< graph_input_nodes_.size(); ++i) {
+    uint32_t nid = graph_input_nodes_[i];
+    if (nodes_[nid].name == name) {
+      return static_cast<int>(i);
+    }
+  }
+  LOG(WARNING) << "Warning: cannot find \"" << name << "\" among input";
+  return -1;
+}
 /*!
  * \brief set index-th input to the graph without copying the data.
  * \param index The input index.
@@ -141,6 +156,33 @@ void GraphRuntime::SetInputZeroCopy(int index, DLTensor* data_ref) {
 int GraphRuntime::NumOutputs() const {
   return outputs_.size();
 }
+/*!
+ * \brief Get the number of graph inputs
+ *
+ * \return The number of inputs to graph.
+ */
+int GraphRuntime::NumInputs() const {
+  return graph_input_nodes_.size();
+}
+
+/*!
+ * \brief Return name_hint of NDArray for given input/output index.
+ * \param type 0 - input 1 - output.
+ * \param index index of input/output.
+ *
+ * \return string of name_hint
+ */
+std::string GraphRuntime::GetNameHint(int type, int index) const {
+  if (type == 0) {
+    CHECK_LT(static_cast<size_t>(index), input_nodes_.size());
+    uint32_t eid = this->entry_id(graph_input_nodes_[index], 0);
+    return data_entry_[eid].name_hint;
+  } else {
+    CHECK_LT(static_cast<size_t>(index), graph_input_nodes_.size());
+    uint32_t eid = this->entry_id(outputs_[index]);
+    return data_entry_[eid].name_hint;
+  }
+}
 /*!
  * \brief Return NDArray for given input index.
  * \param index The input index.
@@ -152,6 +194,17 @@ NDArray GraphRuntime::GetInput(int index) const {
   uint32_t eid = this->entry_id(input_nodes_[index], 0);
   return data_entry_[eid];
 }
+/*!
+ * \brief Return NDArray for given graph input index.
+ * \param index The input index.
+ *
+ * \return NDArray corresponding to given graph input node index.
+ */
+NDArray GraphRuntime::GetGraphInput(int index) const {
+  CHECK_LT(static_cast<size_t>(index), graph_input_nodes_.size());
+  uint32_t eid = this->entry_id(graph_input_nodes_[index], 0);
+  return data_entry_[eid];
+}
 /*!
  * \brief Return NDArray for given output index.
  * \param index The output index.
@@ -208,6 +261,9 @@ void GraphRuntime::LoadParams(dmlc::Stream* strm) {
   size_t size = static_cast<size_t>(sz);
   CHECK(size == names.size())
       << "Invalid parameters file format";
+  // Copy inputs to graph_inputs to extract actual inputs (inputs - params).
+  copy(input_nodes_.begin(), input_nodes_.end(),
+       back_inserter(graph_input_nodes_));
   for (size_t i = 0; i < size; ++i) {
     int in_idx = GetInputIndex(names[i]);
     CHECK_GE(in_idx, 0) << "Found param for non-existent input: " << names[i];
@@ -218,6 +274,10 @@ void GraphRuntime::LoadParams(dmlc::Stream* strm) {
     NDArray temp;
     temp.Load(strm);
     data_entry_[eid].CopyFrom(temp);
+    graph_input_nodes_.erase(std::remove(graph_input_nodes_.begin(),
+                                         graph_input_nodes_.end(),
+                                         input_nodes_[in_idx]),
+                             graph_input_nodes_.end());
   }
 }
 
@@ -313,6 +373,7 @@ void GraphRuntime::SetupStorage() {
     CHECK_LT(static_cast<size_t>(storage_id), storage_pool_.size());
     data_entry_[i] =
         storage_pool_[storage_id].CreateView(attrs_.shape[i], vtype[i]);
+    data_entry_[i].name_hint = this->GetNodeName(i);
     const DLTensor* tmp = data_entry_[i].operator->();
     data_alignment_[i] = details::GetDataAlignment(*tmp);
   }
@@ -450,10 +511,30 @@ PackedFunc GraphRuntime::GetFunction(
         CHECK_GE(in_idx, 0);
         *rv = this->GetInput(in_idx);
       });
+  } else if (name == "get_graph_input") {
+    return PackedFunc([sptr_to_self, this](TVMArgs args, TVMRetValue* rv) {
+        int in_idx = 0;
+        if (args[0].type_code() == kStr) {
+          in_idx = this->GetGraphInputIndex(args[0]);
+        } else {
+          in_idx = args[0];
+        }
+        CHECK_GE(in_idx, 0);
+        *rv = this->GetGraphInput(in_idx);
+      });
   } else if (name == "get_num_outputs") {
     return PackedFunc([sptr_to_self, this](TVMArgs args, TVMRetValue* rv) {
         *rv = this->NumOutputs();
       });
+  } else if (name == "get_num_inputs") {
+    return PackedFunc([sptr_to_self, this](TVMArgs args, TVMRetValue* rv) {
+        *rv = this->NumInputs();
+      });
+  } else if (name == "get_name_hint") {
+    return PackedFunc([sptr_to_self, this](TVMArgs args, TVMRetValue* rv) {
+        // args[0] : 0/1 (input/output) and args[1] : index
+        *rv = this->GetNameHint(args[0], args[1]);
+      });
   } else if (name == "run") {
     return PackedFunc([sptr_to_self, this](TVMArgs args, TVMRetValue* rv) {
         this->Run();
diff --git a/src/runtime/graph/graph_runtime.h b/src/runtime/graph/graph_runtime.h
index c83d68e0815..1ee9dea4d0d 100644
--- a/src/runtime/graph/graph_runtime.h
+++ b/src/runtime/graph/graph_runtime.h
@@ -110,7 +110,12 @@ class GraphRuntime : public ModuleNode {
    * \return The index of input.
    */
   int GetInputIndex(const std::string& name);
-
+  /*!
+   * \brief Get the graph input index given the name of input.
+   * \param name The name of the input.
+   * \return The index of graph input.
+   */
+  int GetGraphInputIndex(const std::string& name);
   /*!
    * \brief set index-th input to the graph.
    * \param index The input index.
@@ -129,6 +134,12 @@ class GraphRuntime : public ModuleNode {
    * \return The number of outputs from graph.
    */
   int NumOutputs() const;
+  /*!
+   * \brief Get the number of inputs
+   *
+   * \return The number of inputs from graph.
+   */
+  int NumInputs() const;
   /*!
    * \brief Return NDArray for given input index.
    * \param index The input index.
@@ -136,6 +147,13 @@ class GraphRuntime : public ModuleNode {
    * \return NDArray corresponding to given input node index.
    */
   NDArray GetInput(int index) const;
+  /*!
+   * \brief Return NDArray for given graph input index.
+   * \param index The graph input index.
+   *
+   * \return NDArray corresponding to given graph input node index.
+   */
+  NDArray GetGraphInput(int index) const;
   /*!
    * \brief Return NDArray for given output index.
    * \param index The output index.
@@ -143,6 +161,14 @@ class GraphRuntime : public ModuleNode {
    * \return NDArray corresponding to given output node index.
    */
   NDArray GetOutput(int index) const;
+  /*!
+   * \brief Return name_hint of NDArray for given input/output index.
+   * \param type 0 - input 1 - output.
+   * \param index index of input/output.
+   *
+   * \return string of name_hint
+   */
+  std::string GetNameHint(int type, int index) const;
   /*!
    * \brief Copy index-th output to data_out.
    * \param index The output index.
@@ -396,6 +422,8 @@ class GraphRuntime : public ModuleNode {
   std::vector<Node> nodes_;
   /*! \brief The argument nodes. */
   std::vector<uint32_t> input_nodes_;
+  /*! \brief The inputs nodes excluding params. */
+  std::vector<uint32_t> graph_input_nodes_;
   /*! \brief Map of input names to input indices. */
   std::unordered_map<std::string, uint32_t> input_map_;
   /*! \brief Used for quick node input DLTensor* lookup given an input eid. */
